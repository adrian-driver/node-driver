package poc

import (
	// "encoding/base64"
	// "encoding/json"
	"fmt"
	"io/ioutil"
	// "strings"
	"time"

	"github.com/docker/machine/libmachine/drivers"
	"github.com/docker/machine/libmachine/log"
	"github.com/docker/machine/libmachine/mcnflag"
	"github.com/docker/machine/libmachine/ssh"
	"github.com/docker/machine/libmachine/state"

	"github.com/pkg/errors"
)

// Driver is the implementation of BaseDriver interface
type Driver struct {
	*drivers.BaseDriver
}


// NewDriver creates and returns a new instance of the PNAP driver
func NewDriver() *Driver {
	return &Driver{
		BaseDriver: &drivers.BaseDriver{},
	}
}

// GetCreateFlags returns the mcnflag.Flag slice representing the flags
// that can be set, their descriptions and defaults.
func (d *Driver) GetCreateFlags() []mcnflag.Flag {
	return []mcnflag.Flag{
		mcnflag.StringFlag{
			EnvVar: "PNAP_SERVER_OS",
			Name:   "pnap-server-os",
			Usage:  "The serverâ€™s OS ID used when the server was created (e.g., ubuntu/bionic, centos/centos7).",
			Value:  "",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_SERVER_LOCATION",
			Name:   "pnap-server-location",
			Usage:  "Server Location ID. Cannot be changed once a server is created",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_SERVER_TYPE",
			Name:   "pnap-server-type",
			Usage:  "Server type ID. Cannot be changed once a server is created",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_SERVER_DESCRIPTION",
			Name:   "pnap-server-description",
			Usage:  "Server description",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_SERVER_HOSTNAME",
			Name:   "pnap-server-hostname",
			Usage:  "Server hostname",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_CLIENT_ID",
			Name:   "pnap-client-identifier",
			Usage:  "Client ID from Application Credentials",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_CLIENT_SECRET",
			Name:   "pnap-client-secret",
			Usage:  "Client Secret from Application Credentials",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_CLIENT_TOKEN",
			Name:   "pnap-client-token",
			Usage:  "Client Token generated by Authentication Service",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_SERVER_PRIVATE_NETWORK",
			Name:   "pnap-server-private-network",
			Usage:  "Private Network ID",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_SERVER_GATEWAY",
			Name:   "pnap-server-gateway",
			Usage:  "Server Gateway",
		},
		mcnflag.BoolFlag{
			EnvVar: "PNAP_PRIVATE_NETWORKING",
			Name:   "pnap-private-networking",
			Usage:  "Defines whether to use private network for communication.",
		},
		mcnflag.StringFlag{
			EnvVar: "PNAP_USERDATA",
			Name:   "pnap-userdata",
			Usage:  "path to file with cloud-init user data",
		},
	}
}

// DriverName returns the name of the driver
func (d *Driver) DriverName() string {
	return "poc"
}

// SetConfigFromFlags configures the driver with the object that was returned
// by RegisterCreateFlags
func (d *Driver) SetConfigFromFlags(flags drivers.DriverOptions) error {

	return nil
}
func (d *Driver) createSSHKey() (string, error) {
	if err := ssh.GenerateSSHKey(d.GetSSHKeyPath()); err != nil {
		return "", err
	}

	publicKey, err := ioutil.ReadFile(d.publicSSHKeyPath())
	if err != nil {
		return "", err
	}

	return string(publicKey), nil
}

// publicSSHKeyPath is always SSH Key Path appended with ".pub"
func (d *Driver) publicSSHKeyPath() string {
	return d.GetSSHKeyPath() + ".pub"
}

// Create a host using the driver's config
func (d *Driver) Create() error {
	log.Info("Creating pnap machine instance...")

	return nil
}

// GetSSHHostname returns hostname for use with ssh
func (d *Driver) GetSSHHostname() (string, error) {
	return d.GetIP()
}

// GetIP returns IP to use in communication
func (d *Driver) GetIP() (string, error) {
	log.Debug("pnap.GetIP()")

	return d.IPAddress, nil
}

// GetState returns the state that the host is in (running, stopped, etc)
func (d *Driver) GetState() (state.State, error) {
	return state.Running, nil
}

// GetURL returns a Docker compatible host URL for connecting to this host
// e.g. tcp://1.2.3.4:2376
func (d *Driver) GetURL() (string, error) {
	ip, err := d.GetIP()
	if err != nil {
		return "", err
	}
	if ip == "" {
		return "", nil
	}

	return fmt.Sprintf("tcp://%s:%d", ip, 2376), nil
}

func (d *Driver) waitForStatus(a state.State) error {
	for {
		//log.Infof("Waiting for Machine %s...", a.String())
		act, err := d.GetState()
		if err != nil {
			return errors.Wrap(err, "Could not get Server state.")
		}

		if act == a {
			log.Infof("Created pnap machine reached state %s.", a.String())
			break
		} else if act == state.Error {
			return errors.Wrap(err, "Server state could not be retrived.")
		}

		log.Infof("Waiting for Machine %s...", a.String())
		time.Sleep(10 * time.Second)
	}
	return nil
}

// Kill stops a host forcefully
func (d *Driver) Kill() error {
	return nil
}

// Remove a host
func (d *Driver) Remove() error {
	return nil
}

// Restart a host. This may just call Stop(); Start() if the provider does not
// have any special restart behaviour.
func (d *Driver) Restart() error {
	return nil
}

// Start a host
func (d *Driver) Start() error {
	return nil
}

// Stop a host gracefully
func (d *Driver) Stop() error {
	return nil
}

/* func run(command command.Executor) error {
	resp, err := command.Execute()
	if err != nil {
		return err
	}
	code := resp.StatusCode
	if code != 200 {
		response := &dto.ErrorMessage{}
		response.FromBytes(resp)
		return fmt.Errorf("API Returned Code: %v, Message: %v, Validation Errors: %v", code, response.Message, response.ValidationErrors)
	}
	return nil
} */

// PreCreateCheck allows for pre-create operations to make sure a driver is ready for creation
func (d *Driver) PreCreateCheck() error {

	return nil
}

// GetSSHUsername returns username for use with ssh
func (d *Driver) GetSSHUsername() string {
	d.SSHUser = "ubuntu"
	return d.SSHUser
}

// setTokenToEmptySTring invalidates token.
// Token is definitelly expired after one hour, and this method enables other ways of authentication.
func (d *Driver) setTokenToEmptySTring() {
}

func (d *Driver) isTokenValid() bool {
	return true
}
